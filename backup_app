from flask import Flask, request, jsonify, render_template, session, redirect
from Bot_Final import UltraChatBot
import json
import firebase_admin
from firebase_admin import credentials, db
import os
import pdfplumber
import re
import nltk
from transformers import T5Tokenizer, T5ForConditionalGeneration

# Ensure NLTK tokenizer is available
nltk.download("punkt", quiet=True)
from nltk.tokenize import sent_tokenize

app = Flask(__name__)
app.secret_key = "your_secret_key"

# Initialize Firebase Admin SDK
cred = credentials.Certificate("fbconfig.json")
firebase_admin.initialize_app(cred, {
    'databaseURL': 'https://projectcg4-6c3b1-default-rtdb.firebaseio.com/'
})

PROJECT_UPLOAD_FOLDER = "uploads"  # Inside the project directory
EXTERNAL_UPLOAD_FOLDER = "D:/Saved_PDFs"  # Specific location in D drive

# Ensure both folders exist
os.makedirs(PROJECT_UPLOAD_FOLDER, exist_ok=True)
os.makedirs(EXTERNAL_UPLOAD_FOLDER, exist_ok=True)

# Load T5 Model for QA
model_name = "google/flan-t5-large"
tokenizer = T5Tokenizer.from_pretrained(model_name)
model = T5ForConditionalGeneration.from_pretrained(model_name)

def extract_text_from_pdf(pdf_path):
    """Extracts and cleans text from a given PDF file."""
    text = []
    try:
        with pdfplumber.open(pdf_path) as pdf:
            for page in pdf.pages:
                page_text = page.extract_text()
                if page_text:
                    cleaned_text = re.sub(r'\s+', ' ', page_text.strip())
                    text.append(cleaned_text)
    except Exception as e:
        print(f"Error reading PDF: {e}")
        return None
    return " ".join(text) if text else None

def generate_answer(question, context):
    """Generates the best possible answer using T5."""
    if not context:
        return "No text found in the PDF."
    input_text = f"question: {question} context: {context}"
    inputs = tokenizer(input_text, return_tensors="pt", truncation=True, max_length=512)
    outputs = model.generate(**inputs, max_length=150)
    return tokenizer.decode(outputs[0], skip_special_tokens=True)

@app.route('/')
def login_page():
    return render_template('login.html')

@app.route('/login', methods=['POST'])
def login():
    data = request.json
    email = data.get("email")
    password = data.get("password")
    
    for user_type in ['users', 'employees']:
        users_ref = db.reference(user_type)
        users_data = users_ref.get()
        if users_data:
            for user_id, user_info in users_data.items():
                if user_info.get("email") == email and user_info.get("password") == password:
                    session['user'] = user_id
                    session['user_type'] = user_type
                    return jsonify({"success": True, "redirect": "/bot"}), 200
    return jsonify({"success": False, "message": "Invalid credentials."}), 401

@app.route('/register', methods=['POST'])
def register():
    data = request.json
    name, email, contact, password, confirm_password, user_type = data.values()
    if password != confirm_password:
        return jsonify({"success": False, "message": "Passwords do not match!"}), 400
    node = "users" if user_type == "user" else "employees"
    users_ref = db.reference(node)
    if any(user.get('email') == email for user in (users_ref.get() or {}).values()):
        return jsonify({"success": False, "message": "Email already registered!"}), 409
    users_ref.push({ 'name': name, 'email': email, 'contact': contact, 'password': password, 'user_type': user_type })
    return jsonify({"success": True, "redirect": "/"}), 201

@app.route('/logout')
def logout():
    session.clear()
    return redirect('/')

@app.route('/bot')
def index():
    if 'user' not in session:
        return redirect('/')
    return render_template('index.html')

@app.route('/mybot', methods=['POST'])
def mybot():
    user_type = session.get('user_type', 'user')
    user_message = request.json.get('data', '')
    bot = UltraChatBot(user_type)
    bot_response = bot.process_incoming_message(user_message)
    return jsonify(bot_response)

@app.route("/pdf.html")
def upload_pdf_page():
    return render_template("pdf.html")

@app.route("/upload_pdf", methods=["POST"])
def upload_pdf():
    if "user" not in session:
        return jsonify({"success": False, "message": "User not logged in."}), 401

    user_id = session["user"]
    user_type = session.get("user_type", "users")  # Default to 'users' if not found

    if "file" not in request.files:
        return jsonify({"success": False, "message": "No file uploaded."}), 400

    file = request.files["file"]
    
    if file.filename == "" or not file.filename.lower().endswith(".pdf"):
        return jsonify({"success": False, "message": "Invalid file format."}), 400

    # Define file paths
    project_path = os.path.join("uploads", file.filename)
    external_path = os.path.join("D:/Saved_PDFs", file.filename)

    try:
        # Save the file in both locations
        file.save(project_path)
        file.save(external_path)

        # Extract text from the PDF
        extracted_text = extract_text_from_pdf(project_path)
        session["pdf_text"] = extracted_text

        # Store the file path in Firebase under the user's node
        user_ref = db.reference(f"{user_type}/{user_id}/uploaded_files")
        user_ref.push({
            "filename": file.filename,
            "project_path": project_path,
            "external_path": external_path
        })

        return jsonify({
            "success": True,
            "message": "PDF uploaded successfully!",
            "project_path": project_path,
            "external_path": external_path
        })
    except Exception as e:
        return jsonify({"success": False, "message": f"Error saving file: {str(e)}"}), 500



@app.route("/ask", methods=["POST"])
def ask_question():
    question = request.json.get("question", "")
    context = session.get('pdf_text', "")
    answer = generate_answer(question, context)
    return jsonify({"answer": answer})

if __name__ == '__main__':
    app.run(debug=True)
